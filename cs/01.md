# 01-동기 비동기

## 락과 언락의 차이

### 락 (Lock)

* 어떤 자원에 대해 배타적 접근을 허용한다. (다른 프로세스/스레드는 접근 불가하다)

### 언락 (Unlock)

* 락을 해제해서 다른 작업이 접근 가능하도록 한다.

## 블로킹과 논블로킹의 차이

### 블로킹

* 호출되는 함수가 작업을 모두 마칠 때까지 제어권을 가지고 있고, 호출한 함수는 대기하고 있다.

### 논블로킹

* 호출된 함수가 바로 제어권을 리턴하고, 콜백을 할 때까지 호출한 함수가 다른 일을 수행할 수 있다.

## 동기와 비동기의 차이

### 동기(Synchronous)

* 함수의 작업 완료 여부를 호출한 함수가 체크한다.

### 비동기

* 호출하는 함수의 작업 완료 여부를 신경쓰지 않는다.

## 예제 1

Web3j는 비동기 요청이면서 Blocking 이다.\
내부적으로 비동기 요청을 처리하지만, 결과를 기다렸다가 리턴하기 때문에 Blocking 함수이다.

## 예제 2

> 분산 시스템 서비스의 경우, 다른 API 서버의 RestAPI를 호출하여 데이터를 처리하는 경우가 매우 흔하다.\
> 이 경우, 어떤 문제가 발생할까?

* Spring MVC는 Thread per request model로 사용자의 요청이 들어오면, Thread Pool에서 Thread를 선택하여 비즈니스 로직을 수행하게 된다.
* 그렇다면, task#1 (A server) -> task#2 (B server) -> task#3 (A server)의 과정에서 A server는 block이 되어 task#1 \~ task#3 사이에 다른 업무 수행을 할 수 없는 상태가 된다.
* Thread가 waiting <-> runnable 상태로 계속 context switching 되어 오버헤드가 발생하게 된다. 이는 시스템의 부하가 큰 경우 문제가 될 수 있다.

> 비동기 환경에서 동기적으로 작동하는 함수를 사용한다면 어떤 문제가 발생할까

* 동기 함수는 호출된 후, 결과가 반환될 때까지 호출한 스레드를 기다려야 한다.
* 비동기 프로그래밍의 목적은 논블로킹 방식으로 여러 작업을 동시에 처리하여 시스템의 효율성을 높이는 것이 목적이다.
* 이렇듯 비동기 환경에서 동기 함수를 호출하면, 그 호출이 완료될 때까지 스레드는 대기하게 되기 때문에 블로킹이 발생하여 비동기 환경의 기본 이념에 어긋나게 된다.

[참고 영상](https://www.youtube.com/watch?v=I0zMm6wIbRI)

### 나의 경험

* RestTemplate 사용으로 인한 동기/블록킹 작업을 자바21 가상 쓰레드로 해결
